# ä¸¤é˜¶æ®µæ™ºèƒ½æ„å›¾è¯†åˆ«æ–¹æ¡ˆ

> åŸºäºPromptAgentV2çš„è¿›åŒ–è®¾è®¡
> è®¾è®¡æ—¥æœŸï¼š2025å¹´2æœˆ

---

## ç›®å½•

1. [æ¶æ„è®¾è®¡æ¦‚è¿°](#ä¸€æ¶æ„è®¾è®¡æ¦‚è¿°)
2. [ç¬¬ä¸€é˜¶æ®µï¼šç²—ç²’åº¦æ„å›¾è¯†åˆ«ä¸ä¸Šä¸‹æ–‡ç­›é€‰](#äºŒç¬¬ä¸€é˜¶æ®µç²—ç²’åº¦æ„å›¾è¯†åˆ«ä¸ä¸Šä¸‹æ–‡ç­›é€‰)
3. [ç¬¬äºŒé˜¶æ®µï¼šç»†ç²’åº¦æ„å›¾åˆ†è§£ä¸è·¯ç”±å†³ç­–](#ä¸‰ç¬¬äºŒé˜¶æ®µç»†ç²’åº¦æ„å›¾åˆ†è§£ä¸è·¯ç”±å†³ç­–)
4. [ä¸Šä¸‹æ–‡æ ¼å¼è®¾è®¡](#å››ä¸Šä¸‹æ–‡æ ¼å¼è®¾è®¡)
5. [æ¶ˆæ­§æœºåˆ¶è®¾è®¡](#äº”æ¶ˆæ­§æœºåˆ¶è®¾è®¡)
6. [å®Œæ•´ä»£ç å®ç°](#å…­å®Œæ•´ä»£ç å®ç°)
7. [ä¸ç°æœ‰ç³»ç»Ÿé›†æˆ](#ä¸ƒä¸ç°æœ‰ç³»ç»Ÿé›†æˆ)
8. [æ€§èƒ½ä¼˜åŒ–å»ºè®®](#å…«æ€§èƒ½ä¼˜åŒ–å»ºè®®)

---

## ä¸€ã€æ¶æ„è®¾è®¡æ¦‚è¿°

### 1.1 æ ¸å¿ƒæ€æƒ³

é‡‡ç”¨**"å…ˆç­›é€‰ã€ååˆ†è§£"**çš„ä¸¤é˜¶æ®µç­–ç•¥ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     ä¸¤é˜¶æ®µæ„å›¾è¯†åˆ«æ¶æ„                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  Stage 1: ç²—ç²’åº¦è¯†åˆ« + ä¸Šä¸‹æ–‡ç­›é€‰                                  â”‚
â”‚  â”œâ”€â”€ è¾“å…¥: ç”¨æˆ·Query + å®Œæ•´å†å²ä¸Šä¸‹æ–‡                              â”‚
â”‚  â”œâ”€â”€ å¤„ç†: LLMåˆ¤æ–­æ•´ä½“æ„å›¾ç±»å‹ + ç­›é€‰ç›¸å…³ä¸Šä¸‹æ–‡                     â”‚
â”‚  â””â”€â”€ è¾“å‡º: ç²—æ„å›¾æ ‡ç­¾ + ç­›é€‰åçš„ä¸Šä¸‹æ–‡åˆ—è¡¨                          â”‚
â”‚                              â†“                                   â”‚
â”‚  Stage 2: ç»†ç²’åº¦åˆ†è§£ + è·¯ç”±å†³ç­–                                    â”‚
â”‚  â”œâ”€â”€ è¾“å…¥: ç”¨æˆ·Query + ç­›é€‰åçš„ä¸Šä¸‹æ–‡                              â”‚
â”‚  â”œâ”€â”€ å¤„ç†: é—®é¢˜æ‹†è§£ + æ¶ˆæ­§åˆ¤æ–­ + è·¯ç”±åˆ†é…                           â”‚
â”‚  â””â”€â”€ è¾“å‡º: å­é—®é¢˜åˆ—è¡¨(å«æ¶ˆæ­§æ ‡è®°) + è·¯ç”±å†³ç­– + ç½®ä¿¡åº¦               â”‚
â”‚                              â†“                                   â”‚
â”‚  æ‰§è¡Œå±‚: DAGæ‰§è¡Œæˆ–æ¶ˆæ­§äº¤äº’                                         â”‚
â”‚  â”œâ”€â”€ æ— éœ€æ¶ˆæ­§: ç›´æ¥ç”ŸæˆDAGæ‰§è¡Œ                                     â”‚
â”‚  â””â”€â”€ éœ€è¦æ¶ˆæ­§: è§¦å‘æ¾„æ¸…å¯¹è¯ â†’ é‡æ–°è¯†åˆ«                              â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 ä¸ç°æœ‰æ¶æ„å¯¹æ¯”

| ç»´åº¦ | ç°æœ‰PromptAgentV2 | æ–°æ–¹æ¡ˆ |
|------|------------------|--------|
| **è¯†åˆ«ç²’åº¦** | å•ä¸€è·¯ç”±æ ‡ç­¾(3ç§) | å¤šç»´åº¦åˆ†è§£(æ„å›¾+å­é—®é¢˜+æ¶ˆæ­§) |
| **ä¸Šä¸‹æ–‡å¤„ç†** | å…¨é‡ä¼ å…¥ | æ™ºèƒ½ç­›é€‰ï¼Œåªä¼ å…¥ç›¸å…³ä¸Šä¸‹æ–‡ |
| **æ¶ˆæ­§èƒ½åŠ›** | æ—  | æ¯ä¸ªå­é—®é¢˜ç‹¬ç«‹åˆ¤æ–­ |
| **é—®é¢˜æ‹†è§£** | æ—  | å¤æ‚é—®é¢˜è‡ªåŠ¨æ‹†è§£ |
| **è·¯ç”±ç²¾åº¦** | åŸºäºå…³é”®è¯åŒ¹é… | åŸºäºè¯­ä¹‰ç†è§£ |
| **ç½®ä¿¡åº¦** | ç®€å•è§„åˆ™è®¡ç®— | å¤šå› ç´ ç»¼åˆè¯„ä¼° |

### 1.3 æ ¸å¿ƒä¼˜åŠ¿

1. **ä¸Šä¸‹æ–‡é™å™ª**ï¼šåªä¿ç•™ç›¸å…³å†å²ï¼Œå‡å°‘å¹²æ‰°
2. **ç²¾å‡†è·¯ç”±**ï¼šç»†ç²’åº¦ç†è§£ç”¨æˆ·çœŸå®æ„å›¾
3. **ä¸»åŠ¨æ¶ˆæ­§**ï¼šåœ¨é—®é¢˜æ‹†è§£é˜¶æ®µè¯†åˆ«æ­§ä¹‰ç‚¹
4. **çµæ´»æ‹†è§£**ï¼šå¤æ‚é—®é¢˜åˆ†è§£ä¸ºå¯ç®¡ç†çš„å­é—®é¢˜
5. **å¯è§£é‡Šæ€§**ï¼šæ¯ä¸ªå†³ç­–éƒ½æœ‰æ˜ç¡®ç†ç”±

---

## äºŒã€ç¬¬ä¸€é˜¶æ®µï¼šç²—ç²’åº¦æ„å›¾è¯†åˆ«ä¸ä¸Šä¸‹æ–‡ç­›é€‰

### 2.1 åŠŸèƒ½èŒè´£

**è¾“å…¥**ï¼š
- `current_query`: å½“å‰ç”¨æˆ·è¾“å…¥
- `session_history`: å®Œæ•´ä¼šè¯å†å²ï¼ˆå«æ€»ç»“ï¼‰
- `available_docs`: å¯ç”¨æ–‡æ¡£åˆ—è¡¨

**è¾“å‡º**ï¼š
- `coarse_intent`: ç²—ç²’åº¦æ„å›¾æ ‡ç­¾
- `relevant_context_ids`: ç›¸å…³ä¸Šä¸‹æ–‡IDåˆ—è¡¨
- `context_summary`: ç­›é€‰ç†ç”±æ€»ç»“
- `confidence`: ç²—ç²’åº¦ç½®ä¿¡åº¦

### 2.2 ç²—ç²’åº¦æ„å›¾åˆ†ç±»

```python
class CoarseIntent(Enum):
    # æ— éœ€æ£€ç´¢ç±»
    CHITCHAT = "chitchat"           # é—²èŠé—®å€™
    META_QUERY = "meta_query"       # å…³äºç³»ç»Ÿçš„é—®é¢˜
    CONFIRMATION = "confirmation"   # ç¡®è®¤/ç»“æŸå¯¹è¯
    
    # å•è½®æ£€ç´¢ç±»
    SINGLE_FACT = "single_fact"     # å•äº‹å®æŸ¥è¯¢
    PROCEDURE = "procedure"         # æµç¨‹/æ­¥éª¤æŸ¥è¯¢
    DEFINITION = "definition"       # å®šä¹‰/æ¦‚å¿µæŸ¥è¯¢
    
    # å¤šè½®å¤æ‚ç±»
    MULTI_FACT = "multi_fact"       # å¤šäº‹å®æŸ¥è¯¢
    COMPARISON = "comparison"       # å¯¹æ¯”/æ¯”è¾ƒ
    TROUBLESHOOTING = "troubleshooting"  # æ•…éšœæ’æŸ¥
    ANALYSIS = "analysis"           # åˆ†æ/æ¨ç†
    
    # éœ€è¦æ¾„æ¸…ç±»
    AMBIGUOUS = "ambiguous"         # æ„å›¾ä¸æ˜ç¡®
    OUT_OF_DOMAIN = "out_of_domain" # è¶…å‡ºé¢†åŸŸèŒƒå›´
```

### 2.3 ä¸Šä¸‹æ–‡ç­›é€‰ç­–ç•¥

**ç­›é€‰ç»´åº¦**ï¼š
1. **è¯é¢˜ç›¸å…³æ€§**ï¼šä¸å½“å‰queryçš„è¯é¢˜æ˜¯å¦ç›¸å…³
2. **å®ä½“ç»§æ‰¿**ï¼šæ˜¯å¦åŒ…å«å½“å‰queryæ¶‰åŠçš„å®ä½“
3. **æ—¶é—´è¡°å‡**ï¼šè¿‘æœŸå¯¹è¯ä¼˜å…ˆçº§æ›´é«˜
4. **æ„å›¾è¿è´¯æ€§**ï¼šç›¸åŒæ„å›¾çš„å†å²å¯¹è¯æ›´ç›¸å…³

**è¾“å‡ºæ ¼å¼**ï¼š
```json
{
  "coarse_intent": "comparison",
  "confidence": 0.85,
  "relevant_context_indices": [0, 2, 5],
  "selection_reasoning": "ç”¨æˆ·æ­£åœ¨å¯¹æ¯”Aå’ŒBäº§å“ï¼Œå†å²å¯¹è¯ä¸­æåˆ°äº†Aäº§å“çš„ä»·æ ¼ï¼ˆcontext 0ï¼‰ã€Bäº§å“çš„åŠŸèƒ½ï¼ˆcontext 2ï¼‰ï¼Œä»¥åŠç”¨æˆ·çš„ä½¿ç”¨åœºæ™¯ï¼ˆcontext 5ï¼‰",
  "suggested_doc_scope": ["product_catalog", "pricing_guide"],
  "needs_refinement": true
}
```

### 2.4 Stage 1 Promptè®¾è®¡

```yaml
system_prompt: |
  ä½ æ˜¯æ™ºèƒ½å®¢æœç³»ç»Ÿçš„æ„å›¾è¯†åˆ«ä¸“å®¶ã€‚ä½ çš„ä»»åŠ¡æ˜¯ï¼š
  1. åˆ†æç”¨æˆ·çš„å½“å‰æŸ¥è¯¢ï¼Œåˆ¤æ–­æ•´ä½“æ„å›¾ç±»å‹
  2. ä»ä¼šè¯å†å²ä¸­ç­›é€‰å‡ºä¸å½“å‰æŸ¥è¯¢ç›¸å…³çš„ä¸Šä¸‹æ–‡
  3. è¯„ä¼°ç½®ä¿¡åº¦å¹¶ç»™å‡ºç†ç”±
  
  ## æ„å›¾ç±»å‹å®šä¹‰
  - CHITCHAT: é—²èŠé—®å€™ï¼ˆä½ å¥½ã€è°¢è°¢ã€å†è§ç­‰ï¼‰
  - META_QUERY: å…³äºç³»ç»Ÿæœ¬èº«çš„é—®é¢˜ï¼ˆ"ä½ èƒ½åšä»€ä¹ˆ"ã€"æ€ä¹ˆä½¿ç”¨"ï¼‰
  - CONFIRMATION: ç¡®è®¤æˆ–ç»“æŸå¯¹è¯ï¼ˆ"æ˜ç™½äº†"ã€"å¥½çš„"ï¼‰
  - SINGLE_FACT: å•äº‹å®æŸ¥è¯¢ï¼ˆ"Xçš„ä»·æ ¼æ˜¯å¤šå°‘"ï¼‰
  - PROCEDURE: æµç¨‹æŸ¥è¯¢ï¼ˆ"å¦‚ä½•ç”³è¯·é€€æ¬¾"ï¼‰
  - DEFINITION: å®šä¹‰æŸ¥è¯¢ï¼ˆ"ä»€ä¹ˆæ˜¯X"ï¼‰
  - MULTI_FACT: å¤šäº‹å®æŸ¥è¯¢ï¼ˆ"Aå’ŒBçš„ä»·æ ¼åˆ†åˆ«æ˜¯å¤šå°‘"ï¼‰
  - COMPARISON: å¯¹æ¯”æŸ¥è¯¢ï¼ˆ"Aå’ŒBæœ‰ä»€ä¹ˆåŒºåˆ«"ï¼‰
  - TROUBLESHOOTING: æ•…éšœæ’æŸ¥ï¼ˆ"æ— æ³•ç™»å½•æ€ä¹ˆåŠ"ï¼‰
  - ANALYSIS: åˆ†ææ¨ç†ï¼ˆ"ä¸ºä»€ä¹ˆXä¼šå¤±è´¥"ï¼‰
  - AMBIGUOUS: æ„å›¾ä¸æ˜ç¡®ï¼Œéœ€è¦æ¾„æ¸…
  - OUT_OF_DOMAIN: è¶…å‡ºæœåŠ¡èŒƒå›´
  
  ## ä¸Šä¸‹æ–‡ç­›é€‰åŸåˆ™
  1. åªä¿ç•™ä¸å½“å‰æŸ¥è¯¢ç›´æ¥ç›¸å…³çš„å†å²å¯¹è¯
  2. ä¼˜å…ˆé€‰æ‹©åŒ…å«ç›¸åŒå®ä½“æˆ–è¯é¢˜çš„ä¸Šä¸‹æ–‡
  3. è¿‘æœŸå¯¹è¯ï¼ˆæœ€è¿‘3è½®ï¼‰é»˜è®¤ä¿ç•™
  4. å¦‚æœä¸Šä¸‹æ–‡æ— å…³ï¼Œå¯ä»¥è¿”å›ç©ºåˆ—è¡¨
  
  ## è¾“å‡ºæ ¼å¼
  å¿…é¡»è¿”å›JSONæ ¼å¼ï¼š
  {
    "coarse_intent": "æ„å›¾ç±»å‹",
    "confidence": 0.0-1.0,
    "relevant_context_indices": [ç›¸å…³ä¸Šä¸‹æ–‡çš„ç´¢å¼•åˆ—è¡¨],
    "selection_reasoning": "ç­›é€‰ç†ç”±ï¼ˆä¸­æ–‡ï¼‰",
    "suggested_doc_scope": [å»ºè®®æ£€ç´¢çš„æ–‡æ¡£ç±»å‹],
    "needs_refinement": true/false
  }

user_prompt_template: |
  ## å½“å‰ç”¨æˆ·æŸ¥è¯¢
  "{{current_query}}"
  
  ## å¯ç”¨æ–‡æ¡£ç±»å‹
  {{available_docs}}
  
  ## ä¼šè¯å†å²ï¼ˆæŒ‰æ—¶é—´å€’åºï¼Œæœ€æ–°çš„åœ¨å‰ï¼‰
  {{session_history}}
  
  ## ä»»åŠ¡
  1. åˆ¤æ–­å½“å‰æŸ¥è¯¢çš„æ•´ä½“æ„å›¾ç±»å‹
  2. ä»ä¸Šè¿°å†å²ä¸­ç­›é€‰å‡ºç›¸å…³çš„ä¸Šä¸‹æ–‡ï¼ˆæä¾›ç´¢å¼•åˆ—è¡¨ï¼‰
  3. è§£é‡Šä¸ºä»€ä¹ˆè¿™äº›ä¸Šä¸‹æ–‡æ˜¯ç›¸å…³çš„
  4. å»ºè®®éœ€è¦æ£€ç´¢å“ªäº›æ–‡æ¡£ç±»å‹
  5. åˆ¤æ–­æ˜¯å¦éœ€è¦è¿›ä¸€æ­¥ç»†åŒ–åˆ†æ
  
  è¯·è¿”å›JSONæ ¼å¼çš„åˆ†æç»“æœã€‚
```

---

## ä¸‰ã€ç¬¬äºŒé˜¶æ®µï¼šç»†ç²’åº¦æ„å›¾åˆ†è§£ä¸è·¯ç”±å†³ç­–

### 2.1 åŠŸèƒ½èŒè´£

**è¾“å…¥**ï¼š
- `current_query`: å½“å‰ç”¨æˆ·è¾“å…¥
- `filtered_context`: ç­›é€‰åçš„ç›¸å…³ä¸Šä¸‹æ–‡
- `coarse_intent`: ç²—ç²’åº¦æ„å›¾æ ‡ç­¾

**è¾“å‡º**ï¼š
- `sub_problems`: å­é—®é¢˜åˆ—è¡¨
- `routing_plan`: è·¯ç”±è®¡åˆ’
- `clarification_needed`: æ˜¯å¦éœ€è¦æ¾„æ¸…
- `overall_confidence`: æ•´ä½“ç½®ä¿¡åº¦

### 2.2 å­é—®é¢˜ç»“æ„

```python
class SubProblem(BaseModel):
    id: str                          # å­é—®é¢˜ID
    original_text: str               # åŸå§‹æ–‡æœ¬ï¼ˆä»queryæå–ï¼‰
    refined_question: str            # ä¼˜åŒ–åçš„é—®é¢˜
    intent_type: str                 # ç»†ç²’åº¦æ„å›¾
    entities: List[str]              # æå–çš„å®ä½“
    
    # æ¶ˆæ­§ç›¸å…³
    needs_clarification: bool        # æ˜¯å¦éœ€è¦æ¾„æ¸…
    ambiguity_type: Optional[str]    # æ­§ä¹‰ç±»å‹
    clarification_question: Optional[str]  # æ¾„æ¸…é—®é¢˜
    clarification_options: Optional[List[str]]  # é€‰é¡¹åˆ—è¡¨
    
    # è·¯ç”±ç›¸å…³
    target_agent: str                # ç›®æ ‡Agent
    route_type: RouteType            # è·¯ç”±ç±»å‹
    required_tools: List[str]        # éœ€è¦çš„å·¥å…·
    estimated_complexity: str        # å¤æ‚åº¦è¯„ä¼°
    
    # ä¾èµ–å…³ç³»
    dependencies: List[str]          # ä¾èµ–çš„å…¶ä»–å­é—®é¢˜ID
    can_parallel: bool               # æ˜¯å¦å¯ä»¥å¹¶è¡Œæ‰§è¡Œ
```

### 2.3 æ¶ˆæ­§ç­–ç•¥

**éœ€è¦æ¶ˆæ­§çš„åœºæ™¯**ï¼š
1. **å®ä½“æ­§ä¹‰**ï¼šåŒåä¸åŒå®ä½“ï¼ˆ"è‹¹æœ"æ˜¯æ°´æœè¿˜æ˜¯å…¬å¸ï¼‰
2. **æŒ‡ä»£ä¸æ˜**ï¼šä»£è¯æˆ–æŒ‡ç¤ºè¯ä¸æ¸…æ¥šï¼ˆ"è¿™ä¸ªæ€ä¹ˆæ ·"ï¼‰
3. **èŒƒå›´æ¨¡ç³Š**ï¼šæ—¶é—´ã€æ•°é‡èŒƒå›´ä¸æ˜ç¡®ï¼ˆ"æœ€è¿‘"ã€"ä¸€äº›"ï¼‰
4. **æ„å›¾å¤šé‡**ï¼šä¸€å¥è¯åŒ…å«å¤šä¸ªå¯èƒ½çš„æ„å›¾
5. **ç¼ºå°‘å…³é”®ä¿¡æ¯**ï¼šç¼ºå°‘å¿…è¦çš„å‚æ•°ï¼ˆ"ä»·æ ¼æ˜¯å¤šå°‘"ä½†æ²¡è¯´æ˜¯ä»€ä¹ˆäº§å“ï¼‰

**æ¶ˆæ­§å¤„ç†æ–¹å¼**ï¼š
```python
class ClarificationStrategy(Enum):
    ASK_USER = "ask_user"           # ç›´æ¥è¯¢é—®ç”¨æˆ·
    USE_DEFAULT = "use_default"     # ä½¿ç”¨é»˜è®¤å€¼
    INFER_FROM_CONTEXT = "infer"    # ä»ä¸Šä¸‹æ–‡æ¨æ–­
    EXECUTE_ALL = "execute_all"     # æ‰§è¡Œæ‰€æœ‰å¯èƒ½åˆ†æ”¯
```

### 2.4 Stage 2 Promptè®¾è®¡

```yaml
system_prompt: |
  ä½ æ˜¯æ™ºèƒ½å®¢æœç³»ç»Ÿçš„æŸ¥è¯¢åˆ†æä¸“å®¶ã€‚ä½ çš„ä»»åŠ¡æ˜¯ï¼š
  1. å°†ç”¨æˆ·çš„å¤æ‚æŸ¥è¯¢æ‹†è§£ä¸ºç»†ç²’åº¦çš„å­é—®é¢˜
  2. è¯†åˆ«æ¯ä¸ªå­é—®é¢˜ä¸­çš„æ­§ä¹‰ç‚¹
  3. åˆ¤æ–­æ˜¯å¦éœ€è¦å‘ç”¨æˆ·æ¾„æ¸…
  4. ä¸ºæ¯ä¸ªå­é—®é¢˜åˆ†é…æœ€åˆé€‚çš„è·¯ç”±ç­–ç•¥
  
  ## å­é—®é¢˜ç±»å‹
  - FACT_LOOKUP: äº‹å®æŸ¥è¯¢ï¼ˆä»·æ ¼ã€è§„æ ¼ã€æ—¶é—´ç­‰ï¼‰
  - PROCEDURE_GUIDE: æµç¨‹æŒ‡å¯¼ï¼ˆå¦‚ä½•æ“ä½œã€æ­¥éª¤è¯´æ˜ï¼‰
  - TROUBLESHOOTING: æ•…éšœæ’æŸ¥ï¼ˆé—®é¢˜è§£å†³ã€é”™è¯¯å¤„ç†ï¼‰
  - COMPARISON: å¯¹æ¯”åˆ†æï¼ˆä¼˜ç¼ºç‚¹æ¯”è¾ƒã€å·®å¼‚åˆ†æï¼‰
  - EXPLANATION: æ¦‚å¿µè§£é‡Šï¼ˆå®šä¹‰è¯´æ˜ã€åŸç†è®²è§£ï¼‰
  - RECOMMENDATION: æ¨èå»ºè®®ï¼ˆäº§å“æ¨èã€æ–¹æ¡ˆå»ºè®®ï¼‰
  - CALCULATION: è®¡ç®—æ¨å¯¼ï¼ˆè´¹ç”¨è®¡ç®—ã€æ•°é‡æ¨ç®—ï¼‰
  
  ## è·¯ç”±ç±»å‹
  - FAST_PATH: ç›´æ¥å›ç­”ï¼Œæ— éœ€æ£€ç´¢ï¼ˆé—²èŠã€å·²çŸ¥ä¿¡æ¯ï¼‰
  - SINGLE_RETRIEVAL: å•æ¬¡æ£€ç´¢å³å¯å›ç­”
  - MULTI_HOP: éœ€è¦å¤šæ­¥æ¨ç†æˆ–å¤šæ¬¡æ£€ç´¢
  - CLARIFICATION: éœ€è¦å…ˆå‘ç”¨æˆ·æ¾„æ¸…
  - FALLBACK: æ— æ³•å¤„ç†ï¼Œèµ°å…œåº•é€»è¾‘
  
  ## æ¶ˆæ­§åˆ¤æ–­åŸåˆ™
  1. å¦‚æœå­˜åœ¨2ç§ä»¥ä¸Šåˆç†è§£é‡Šï¼Œä¸”æ— æ³•ä»ä¸Šä¸‹æ–‡æ¨æ–­ â†’ éœ€è¦æ¾„æ¸…
  2. å¦‚æœç¼ºå°‘å…³é”®ä¿¡æ¯å¯¼è‡´æ— æ³•å›ç­” â†’ éœ€è¦æ¾„æ¸…
  3. å¦‚æœæŒ‡ä»£è¯ï¼ˆè¿™ä¸ªã€é‚£ä¸ªã€å®ƒï¼‰æ— æ³•ç¡®å®šæŒ‡ä»£å¯¹è±¡ â†’ éœ€è¦æ¾„æ¸…
  4. å¦‚æœæ—¶é—´/èŒƒå›´æ¨¡ç³Šå½±å“ç­”æ¡ˆå‡†ç¡®æ€§ â†’ éœ€è¦æ¾„æ¸…
  
  ## è¾“å‡ºæ ¼å¼
  è¿”å›JSONæ ¼å¼ï¼š
  {
    "analysis": "æ•´ä½“åˆ†æï¼ˆä¸­æ–‡ï¼‰",
    "sub_problems": [
      {
        "id": "sp_1",
        "original_text": "åŸå§‹é—®é¢˜æ–‡æœ¬",
        "refined_question": "ä¼˜åŒ–åçš„é—®é¢˜",
        "intent_type": "å­æ„å›¾ç±»å‹",
        "entities": ["å®ä½“1", "å®ä½“2"],
        "needs_clarification": true/false,
        "ambiguity_type": "æ­§ä¹‰ç±»å‹ï¼ˆå¦‚æœ‰ï¼‰",
        "clarification_question": "æ¾„æ¸…é—®é¢˜ï¼ˆå¦‚éœ€è¦ï¼‰",
        "clarification_options": ["é€‰é¡¹1", "é€‰é¡¹2"],
        "target_agent": "ç›®æ ‡Agent",
        "route_type": "è·¯ç”±ç±»å‹",
        "required_tools": ["å·¥å…·1"],
        "estimated_complexity": "simple/medium/complex",
        "dependencies": [],
        "can_parallel": true/false
      }
    ],
    "overall_confidence": 0.0-1.0,
    "execution_strategy": "parallel/sequential/mixed",
    "suggestions": ["æ‰§è¡Œå»ºè®®"]
  }

user_prompt_template: |
  ## å½“å‰ç”¨æˆ·æŸ¥è¯¢
  "{{current_query}}"
  
  ## ç²—ç²’åº¦æ„å›¾ï¼ˆæ¥è‡ªç¬¬ä¸€é˜¶æ®µï¼‰
  {{coarse_intent}}
  
  ## ç­›é€‰åçš„ç›¸å…³ä¸Šä¸‹æ–‡
  {{filtered_context}}
  
  ## å¯ç”¨å·¥å…·åˆ—è¡¨
  {{available_tools}}
  
  ## ä»»åŠ¡è¦æ±‚
  1. å°†æŸ¥è¯¢æ‹†è§£ä¸ºå­é—®é¢˜ï¼ˆå¦‚æœæ˜¯ç®€å•æŸ¥è¯¢ï¼Œå¯ä»¥åªæœ‰1ä¸ªå­é—®é¢˜ï¼‰
  2. è¯†åˆ«æ¯ä¸ªå­é—®é¢˜ä¸­çš„æ­§ä¹‰ç‚¹
  3. åˆ¤æ–­æ˜¯å¦éœ€è¦å‘ç”¨æˆ·æ¾„æ¸…ï¼Œå¦‚æœéœ€è¦ï¼Œè®¾è®¡æ¾„æ¸…é—®é¢˜å’Œé€‰é¡¹
  4. ä¸ºæ¯ä¸ªå­é—®é¢˜æŒ‡å®šè·¯ç”±ç­–ç•¥
  5. åˆ†æå­é—®é¢˜é—´çš„ä¾èµ–å…³ç³»
  6. ç»™å‡ºæ•´ä½“æ‰§è¡Œå»ºè®®ï¼ˆå¹¶è¡Œ/ä¸²è¡Œ/æ··åˆï¼‰
  
  æ³¨æ„ï¼š
  - å¦‚æœæŸ¥è¯¢æ„å›¾æ˜ç¡®ä¸”æ— æ­§ä¹‰ï¼Œç›´æ¥ç”Ÿæˆæ‰§è¡Œè®¡åˆ’
  - å¦‚æœå‘ç°æ­§ä¹‰ç‚¹ï¼Œä¼˜å…ˆè®¾è®¡æ¾„æ¸…æ–¹æ¡ˆ
  - è€ƒè™‘ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼Œå°½å¯èƒ½æ¨æ–­ç”¨æˆ·æ„å›¾
  
  è¯·è¿”å›JSONæ ¼å¼çš„åˆ†æç»“æœã€‚
```

---

## å››ã€ä¸Šä¸‹æ–‡æ ¼å¼è®¾è®¡

### 4.1 ä¼šè¯å†å²æ¡ç›®æ ¼å¼

```python
class ConversationTurn(BaseModel):
    # åŸºç¡€ä¿¡æ¯
    turn_id: str                    # è½®æ¬¡ID
    timestamp: datetime             # æ—¶é—´æˆ³
    role: str                       # user/assistant
    
    # å†…å®¹ä¿¡æ¯
    original_text: str              # åŸå§‹æ–‡æœ¬
    normalized_text: str            # è§„èŒƒåŒ–åçš„æ–‡æœ¬
    
    # æ€»ç»“ä¿¡æ¯ï¼ˆå…³é”®ï¼‰
    summary: str                    # ä¸€å¥è¯æ€»ç»“
    key_points: List[str]           # å…³é”®ç‚¹åˆ—è¡¨
    
    # å…ƒä¿¡æ¯
    entities: List[Entity]          # æå–çš„å®ä½“
    intent_tag: str                 # æ„å›¾æ ‡ç­¾
    topic_tags: List[str]           # è¯é¢˜æ ‡ç­¾
    
    # å¼•ç”¨ä¿¡æ¯
    referenced_docs: List[str]      # å¼•ç”¨çš„æ–‡æ¡£ID
    generated_answer: Optional[str] # ç”Ÿæˆçš„ç­”æ¡ˆï¼ˆå¦‚æœæ˜¯assistantï¼‰
    
    # åé¦ˆä¿¡æ¯
    user_feedback: Optional[str]    # ç”¨æˆ·åé¦ˆï¼ˆğŸ‘/ğŸ‘ï¼‰
    
    class Entity(BaseModel):
        name: str
        type: str
        value: Optional[str]
        confidence: float
```

### 4.2 ä¸Šä¸‹æ–‡ç¤ºä¾‹

```json
{
  "turn_id": "turn_20250227_001",
  "timestamp": "2025-02-27T10:30:00Z",
  "role": "user",
  "original_text": "æˆ‘æƒ³ä¹°ä¸€å°ç¬”è®°æœ¬ç”µè„‘ï¼Œä¸»è¦ç”¨æ¥ç¼–ç¨‹ï¼Œé¢„ç®—8000å·¦å³",
  "normalized_text": "è´­ä¹°ç¬”è®°æœ¬ç”µè„‘ï¼Œç”¨é€”ç¼–ç¨‹ï¼Œé¢„ç®—8000å…ƒ",
  "summary": "ç”¨æˆ·æƒ³è´­ä¹°8000å…ƒé¢„ç®—çš„ç¼–ç¨‹ç”¨ç¬”è®°æœ¬ç”µè„‘",
  "key_points": ["è´­ä¹°ç¬”è®°æœ¬", "ç”¨é€”ç¼–ç¨‹", "é¢„ç®—8000"],
  "entities": [
    {"name": "ç¬”è®°æœ¬ç”µè„‘", "type": "PRODUCT", "confidence": 0.95},
    {"name": "ç¼–ç¨‹", "type": "USAGE_SCENARIO", "confidence": 0.90},
    {"name": "8000", "type": "PRICE", "value": "8000å…ƒ", "confidence": 0.95}
  ],
  "intent_tag": "PURCHASE_INQUIRY",
  "topic_tags": ["ç¡¬ä»¶", "ç¬”è®°æœ¬", "ç¼–ç¨‹"],
  "referenced_docs": [],
  "user_feedback": null
}
```

### 4.3 ä¸Šä¸‹æ–‡ç­›é€‰åçš„æ ¼å¼

```python
class FilteredContext(BaseModel):
    original_turns: List[ConversationTurn]  # åŸå§‹å¯¹è¯
    selected_indices: List[int]             # é€‰ä¸­çš„ç´¢å¼•
    selection_reason: str                   # é€‰æ‹©ç†ç”±
    
    # èšåˆä¿¡æ¯
    aggregated_entities: List[Entity]       # èšåˆå®ä½“
    topic_continuity: float                 # è¯é¢˜è¿è´¯æ€§è¯„åˆ†
    information_gaps: List[str]             # ä¿¡æ¯ç¼ºå£
```

---

## äº”ã€æ¶ˆæ­§æœºåˆ¶è®¾è®¡

### 5.1 æ¶ˆæ­§æµç¨‹

```
ç”¨æˆ·Query
    â†“
Stage 2åˆ†æ
    â†“
æ£€æµ‹æ­§ä¹‰ç‚¹
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ éœ€è¦æ¶ˆæ­§?                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ YES â†’ ç”Ÿæˆæ¾„æ¸…é—®é¢˜ â†’ è¯¢é—®ç”¨æˆ· â†’ ç­‰å¾…å›ç­” â”‚
â”‚       â†“                              â”‚
â”‚       ç”¨æˆ·æ¾„æ¸…å â†’ é‡æ–°è¿›è¡ŒStage 2åˆ†æ   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ NO  â†’ ç›´æ¥ç”Ÿæˆæ‰§è¡Œè®¡åˆ’ â†’ è¿›å…¥DAGæ‰§è¡Œ    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.2 æ¶ˆæ­§å¯¹è¯ç®¡ç†

```python
class ClarificationSession(BaseModel):
    session_id: str
    original_query: str
    ambiguity_points: List[AmbiguityPoint]
    clarification_turns: List[ClarificationTurn]
    status: str  # pending / resolved / timeout
    
class AmbiguityPoint(BaseModel):
    id: str
    type: str                    # entity/reference/scope/intent
    description: str             # æ­§ä¹‰æè¿°
    possible_interpretations: List[str]  # å¯èƒ½çš„è§£é‡Š
    clarification_question: str  # æ¾„æ¸…é—®é¢˜
    options: List[Option]        # é€‰é¡¹åˆ—è¡¨
    
class Option(BaseModel):
    id: str
    text: str
    value: any
    follow_up_hint: str          # é€‰æ‹©åçš„æç¤º
```

### 5.3 æ¶ˆæ­§ç¤ºä¾‹

**åŸå§‹Query**ï¼š"è‹¹æœæ€ä¹ˆæ ·ï¼Ÿ"

**æ­§ä¹‰è¯†åˆ«**ï¼š
```json
{
  "ambiguity_points": [
    {
      "id": "amb_1",
      "type": "entity",
      "description": "'è‹¹æœ'å¯èƒ½æŒ‡æ°´æœæˆ–è‹¹æœå…¬å¸",
      "possible_interpretations": ["æ°´æœ", "ç§‘æŠ€å…¬å¸"],
      "clarification_question": "æ‚¨æåˆ°çš„'è‹¹æœ'æ˜¯æŒ‡ï¼Ÿ",
      "options": [
        {"id": "opt_1", "text": "æ°´æœï¼ˆè‹¹æœï¼‰", "value": "fruit"},
        {"id": "opt_2", "text": "è‹¹æœå…¬å¸ï¼ˆApple Inc.ï¼‰", "value": "company"},
        {"id": "opt_3", "text": "å…¶ä»–", "value": "other"}
      ]
    }
  ]
}
```

**ç”¨æˆ·æ¾„æ¸…å**ï¼š"æˆ‘æŒ‡çš„æ˜¯è‹¹æœå…¬å¸"

**é‡æ–°åˆ†æ**ï¼š
```json
{
  "sub_problems": [
    {
      "id": "sp_1",
      "refined_question": "è‹¹æœå…¬å¸çš„äº§å“è´¨é‡æ€ä¹ˆæ ·ï¼Ÿ",
      "intent_type": "OPINION_QUERY",
      "needs_clarification": false,
      "target_agent": "ReviewAgent",
      "route_type": "SINGLE_RETRIEVAL"
    }
  ]
}
```

---

## å…­ã€å®Œæ•´ä»£ç å®ç°

### 6.1 æ•°æ®æ¨¡å‹å®šä¹‰

```python
# backend/app/agents/intent_models.py

from typing import List, Optional, Dict, Any
from pydantic import BaseModel
from enum import Enum
from datetime import datetime

class CoarseIntent(str, Enum):
    """ç²—ç²’åº¦æ„å›¾"""
    CHITCHAT = "chitchat"
    META_QUERY = "meta_query"
    CONFIRMATION = "confirmation"
    SINGLE_FACT = "single_fact"
    PROCEDURE = "procedure"
    DEFINITION = "definition"
    MULTI_FACT = "multi_fact"
    COMPARISON = "comparison"
    TROUBLESHOOTING = "troubleshooting"
    ANALYSIS = "analysis"
    AMBIGUOUS = "ambiguous"
    OUT_OF_DOMAIN = "out_of_domain"

class FineIntent(str, Enum):
    """ç»†ç²’åº¦æ„å›¾"""
    FACT_LOOKUP = "fact_lookup"
    PROCEDURE_GUIDE = "procedure_guide"
    TROUBLESHOOTING = "troubleshooting"
    COMPARISON = "comparison"
    EXPLANATION = "explanation"
    RECOMMENDATION = "recommendation"
    CALCULATION = "calculation"
    OPINION_QUERY = "opinion_query"
    STATUS_CHECK = "status_check"

class RouteType(str, Enum):
    """è·¯ç”±ç±»å‹"""
    FAST_PATH = "fast_path"
    SINGLE_RETRIEVAL = "single_retrieval"
    MULTI_HOP = "multi_hop"
    CLARIFICATION = "clarification"
    FALLBACK = "fallback"

class Entity(BaseModel):
    """å®ä½“"""
    name: str
    type: str
    value: Optional[str] = None
    confidence: float = 1.0

class ConversationTurn(BaseModel):
    """ä¼šè¯è½®æ¬¡"""
    turn_id: str
    timestamp: datetime
    role: str  # user/assistant
    original_text: str
    normalized_text: str
    summary: str
    key_points: List[str]
    entities: List[Entity]
    intent_tag: str
    topic_tags: List[str]
    referenced_docs: List[str] = []
    generated_answer: Optional[str] = None
    user_feedback: Optional[str] = None

class CoarseIntentResult(BaseModel):
    """ç²—ç²’åº¦æ„å›¾è¯†åˆ«ç»“æœ"""
    coarse_intent: CoarseIntent
    confidence: float
    relevant_context_indices: List[int]
    selection_reasoning: str
    suggested_doc_scope: List[str]
    needs_refinement: bool

class SubProblem(BaseModel):
    """å­é—®é¢˜"""
    id: str
    original_text: str
    refined_question: str
    intent_type: FineIntent
    entities: List[Entity]
    
    # æ¶ˆæ­§ç›¸å…³
    needs_clarification: bool = False
    ambiguity_type: Optional[str] = None
    clarification_question: Optional[str] = None
    clarification_options: Optional[List[Dict[str, Any]]] = None
    
    # è·¯ç”±ç›¸å…³
    target_agent: str
    route_type: RouteType
    required_tools: List[str] = []
    estimated_complexity: str  # simple/medium/complex
    
    # ä¾èµ–å…³ç³»
    dependencies: List[str] = []
    can_parallel: bool = True

class FineIntentResult(BaseModel):
    """ç»†ç²’åº¦æ„å›¾è¯†åˆ«ç»“æœ"""
    analysis: str
    sub_problems: List[SubProblem]
    overall_confidence: float
    execution_strategy: str  # parallel/sequential/mixed
    suggestions: List[str]
    needs_clarification: bool = False
    clarification_session: Optional[Dict[str, Any]] = None

class RoutingPlan(BaseModel):
    """è·¯ç”±è®¡åˆ’"""
    original_query: str
    coarse_result: CoarseIntentResult
    fine_result: FineIntentResult
    final_route: RouteType
    context_blocks: List[Dict[str, Any]]
    confidence: float
    trace_id: str
```

### 6.2 ç¬¬ä¸€é˜¶æ®µï¼šç²—ç²’åº¦è¯†åˆ«

```python
# backend/app/agents/stage1_coarse_intent.py

import json
from typing import List
from .intent_models import *
from ..core.qa_llm import get_qa_llm
from ..utils.prompt_loader import load_prompt

class Stage1CoarseIntentAgent:
    """ç¬¬ä¸€é˜¶æ®µï¼šç²—ç²’åº¦æ„å›¾è¯†åˆ«ä¸ä¸Šä¸‹æ–‡ç­›é€‰"""
    
    def __init__(self):
        self.llm = get_qa_llm()
        self.system_prompt = load_prompt("stage1_coarse_intent_system")
        self.user_prompt_template = load_prompt("stage1_coarse_intent_user")
        
    async def analyze(
        self,
        current_query: str,
        session_history: List[ConversationTurn],
        available_docs: List[str]
    ) -> CoarseIntentResult:
        """
        æ‰§è¡Œç²—ç²’åº¦æ„å›¾è¯†åˆ«å’Œä¸Šä¸‹æ–‡ç­›é€‰
        """
        # æ ¼å¼åŒ–ä¼šè¯å†å²
        formatted_history = self._format_history(session_history)
        
        # æ„å»ºPrompt
        user_prompt = self.user_prompt_template.format(
            current_query=current_query,
            available_docs="\n".join(f"- {doc}" for doc in available_docs),
            session_history=formatted_history
        )
        
        # è°ƒç”¨LLM
        response = await self.llm.generate(
            system_prompt=self.system_prompt,
            user_prompt=user_prompt,
            temperature=0.3,  # ä½æ¸©åº¦ä¿è¯ç¨³å®šæ€§
            response_format={"type": "json_object"}
        )
        
        # è§£æç»“æœ
        result = json.loads(response)
        
        return CoarseIntentResult(
            coarse_intent=CoarseIntent(result["coarse_intent"]),
            confidence=result["confidence"],
            relevant_context_indices=result["relevant_context_indices"],
            selection_reasoning=result["selection_reasoning"],
            suggested_doc_scope=result.get("suggested_doc_scope", []),
            needs_refinement=result.get("needs_refinement", True)
        )
    
    def _format_history(self, history: List[ConversationTurn]) -> str:
        """æ ¼å¼åŒ–ä¼šè¯å†å²ä¸ºPromptå‹å¥½çš„æ ¼å¼"""
        lines = []
        for i, turn in enumerate(reversed(history)):  # å€’åºï¼Œæœ€æ–°çš„åœ¨å‰
            lines.append(f"[{i}] {turn.role.upper()}: {turn.original_text}")
            lines.append(f"    æ€»ç»“: {turn.summary}")
            lines.append(f"    å®ä½“: {', '.join(e.name for e in turn.entities)}")
            lines.append(f"    è¯é¢˜: {', '.join(turn.topic_tags)}")
            lines.append("")
        return "\n".join(lines)
    
    def filter_context(
        self,
        history: List[ConversationTurn],
        selected_indices: List[int]
    ) -> List[ConversationTurn]:
        """æ ¹æ®ç´¢å¼•ç­›é€‰ä¸Šä¸‹æ–‡"""
        # æ³¨æ„ï¼šhistoryæ˜¯å€’åºçš„ï¼Œéœ€è¦è½¬æ¢ç´¢å¼•
        total = len(history)
        actual_indices = [total - 1 - idx for idx in selected_indices]
        return [history[i] for i in actual_indices if 0 <= i < total]
```

### 6.3 ç¬¬äºŒé˜¶æ®µï¼šç»†ç²’åº¦åˆ†è§£

```python
# backend/app/agents/stage2_fine_intent.py

import json
from typing import List, Dict, Any
from .intent_models import *
from ..core.qa_llm import get_qa_llm
from ..utils.prompt_loader import load_prompt

class Stage2FineIntentAgent:
    """ç¬¬äºŒé˜¶æ®µï¼šç»†ç²’åº¦æ„å›¾åˆ†è§£ä¸è·¯ç”±å†³ç­–"""
    
    def __init__(self):
        self.llm = get_qa_llm()
        self.system_prompt = load_prompt("stage2_fine_intent_system")
        self.user_prompt_template = load_prompt("stage2_fine_intent_user")
        
    async def analyze(
        self,
        current_query: str,
        coarse_result: CoarseIntentResult,
        filtered_context: List[ConversationTurn],
        available_tools: List[str]
    ) -> FineIntentResult:
        """
        æ‰§è¡Œç»†ç²’åº¦æ„å›¾åˆ†è§£å’Œè·¯ç”±å†³ç­–
        """
        # æ ¼å¼åŒ–ä¸Šä¸‹æ–‡
        formatted_context = self._format_filtered_context(filtered_context)
        
        # æ„å»ºPrompt
        user_prompt = self.user_prompt_template.format(
            current_query=current_query,
            coarse_intent=coarse_result.coarse_intent.value,
            filtered_context=formatted_context,
            available_tools="\n".join(f"- {tool}" for tool in available_tools)
        )
        
        # è°ƒç”¨LLM
        response = await self.llm.generate(
            system_prompt=self.system_prompt,
            user_prompt=user_prompt,
            temperature=0.4,  # ç¨é«˜æ¸©åº¦å…è®¸åˆ›é€ æ€§æ‹†è§£
            response_format={"type": "json_object"}
        )
        
        # è§£æç»“æœ
        result = json.loads(response)
        
        # æ„å»ºSubProblemåˆ—è¡¨
        sub_problems = []
        for sp_data in result.get("sub_problems", []):
            sub_problems.append(SubProblem(
                id=sp_data["id"],
                original_text=sp_data["original_text"],
                refined_question=sp_data["refined_question"],
                intent_type=FineIntent(sp_data["intent_type"]),
                entities=[Entity(**e) for e in sp_data.get("entities", [])],
                needs_clarification=sp_data.get("needs_clarification", False),
                ambiguity_type=sp_data.get("ambiguity_type"),
                clarification_question=sp_data.get("clarification_question"),
                clarification_options=sp_data.get("clarification_options"),
                target_agent=sp_data["target_agent"],
                route_type=RouteType(sp_data["route_type"]),
                required_tools=sp_data.get("required_tools", []),
                estimated_complexity=sp_data.get("estimated_complexity", "medium"),
                dependencies=sp_data.get("dependencies", []),
                can_parallel=sp_data.get("can_parallel", True)
            ))
        
        # æ£€æŸ¥æ˜¯å¦éœ€è¦æ¾„æ¸…
        needs_clarification = any(sp.needs_clarification for sp in sub_problems)
        clarification_session = None
        if needs_clarification:
            clarification_session = self._build_clarification_session(
                current_query, sub_problems
            )
        
        return FineIntentResult(
            analysis=result["analysis"],
            sub_problems=sub_problems,
            overall_confidence=result["overall_confidence"],
            execution_strategy=result.get("execution_strategy", "parallel"),
            suggestions=result.get("suggestions", []),
            needs_clarification=needs_clarification,
            clarification_session=clarification_session
        )
    
    def _format_filtered_context(self, context: List[ConversationTurn]) -> str:
        """æ ¼å¼åŒ–ç­›é€‰åçš„ä¸Šä¸‹æ–‡"""
        if not context:
            return "æ— ç›¸å…³å†å²ä¸Šä¸‹æ–‡"
        
        lines = []
        for turn in context:
            lines.append(f"- [{turn.role}] {turn.summary}")
            if turn.entities:
                lines.append(f"  å®ä½“: {', '.join(e.name for e in turn.entities)}")
            if turn.generated_answer:
                lines.append(f"  å›ç­”: {turn.generated_answer[:100]}...")
            lines.append("")
        return "\n".join(lines)
    
    def _build_clarification_session(
        self,
        original_query: str,
        sub_problems: List[SubProblem]
    ) -> Dict[str, Any]:
        """æ„å»ºæ¾„æ¸…ä¼šè¯"""
        ambiguity_points = []
        for sp in sub_problems:
            if sp.needs_clarification:
                ambiguity_points.append({
                    "sub_problem_id": sp.id,
                    "type": sp.ambiguity_type,
                    "question": sp.clarification_question,
                    "options": sp.clarification_options
                })
        
        return {
            "session_id": f"clar_{datetime.now().strftime('%Y%m%d%H%M%S')}",
            "original_query": original_query,
            "ambiguity_points": ambiguity_points,
            "status": "pending"
        }
```

### 6.4 ä¸»æ§åˆ¶å™¨ï¼šä¸¤é˜¶æ®µåè°ƒ

```python
# backend/app/agents/intent_orchestrator.py

from typing import List, Optional
from .intent_models import *
from .stage1_coarse_intent import Stage1CoarseIntentAgent
from .stage2_fine_intent import Stage2FineIntentAgent
from ..utils.logger import get_logger

logger = get_logger(__name__)

class IntentOrchestrator:
    """æ„å›¾è¯†åˆ«ç¼–æ’å™¨ - åè°ƒä¸¤é˜¶æ®µè¯†åˆ«æµç¨‹"""
    
    def __init__(self):
        self.stage1_agent = Stage1CoarseIntentAgent()
        self.stage2_agent = Stage2FineIntentAgent()
        
    async def process(
        self,
        query: str,
        session_history: List[ConversationTurn],
        available_docs: List[str],
        available_tools: List[str],
        trace_ctx: Optional[Dict] = None
    ) -> RoutingPlan:
        """
        æ‰§è¡Œå®Œæ•´çš„ä¸¤é˜¶æ®µæ„å›¾è¯†åˆ«æµç¨‹
        
        æµç¨‹:
        1. Stage 1: ç²—ç²’åº¦è¯†åˆ« + ä¸Šä¸‹æ–‡ç­›é€‰
        2. Stage 2: ç»†ç²’åº¦åˆ†è§£ + è·¯ç”±å†³ç­–
        3. å¦‚æœéœ€è¦æ¾„æ¸…ï¼Œè¿”å›æ¾„æ¸…ä¼šè¯
        4. å¦åˆ™ï¼Œç”Ÿæˆæœ€ç»ˆè·¯ç”±è®¡åˆ’
        """
        trace_id = trace_ctx.get("trace_id") if trace_ctx else None
        
        try:
            # ========== Stage 1: ç²—ç²’åº¦è¯†åˆ« ==========
            logger.info(f"[Stage 1] å¼€å§‹ç²—ç²’åº¦æ„å›¾è¯†åˆ«: {query[:50]}...")
            
            coarse_result = await self.stage1_agent.analyze(
                current_query=query,
                session_history=session_history,
                available_docs=available_docs
            )
            
            logger.info(f"[Stage 1] ç²—æ„å›¾: {coarse_result.coarse_intent.value}, "
                       f"ç½®ä¿¡åº¦: {coarse_result.confidence:.2f}")
            
            # å¦‚æœç½®ä¿¡åº¦è¶³å¤Ÿé«˜ä¸”ä¸éœ€è¦ç»†åŒ–ï¼Œç›´æ¥è¿”å›ç®€å•è·¯ç”±
            if (coarse_result.confidence > 0.9 and 
                not coarse_result.needs_refinement and
                coarse_result.coarse_intent in [
                    CoarseIntent.CHITCHAT, 
                    CoarseIntent.CONFIRMATION
                ]):
                return self._build_simple_routing_plan(query, coarse_result, trace_id)
            
            # ç­›é€‰ä¸Šä¸‹æ–‡
            filtered_context = self.stage1_agent.filter_context(
                session_history, 
                coarse_result.relevant_context_indices
            )
            
            logger.info(f"[Stage 1] ç­›é€‰ä¸Šä¸‹æ–‡: {len(filtered_context)}/{len(session_history)} è½®")
            
            # ========== Stage 2: ç»†ç²’åº¦åˆ†è§£ ==========
            logger.info(f"[Stage 2] å¼€å§‹ç»†ç²’åº¦æ„å›¾åˆ†è§£...")
            
            fine_result = await self.stage2_agent.analyze(
                current_query=query,
                coarse_result=coarse_result,
                filtered_context=filtered_context,
                available_tools=available_tools
            )
            
            logger.info(f"[Stage 2] æ‹†è§£å­é—®é¢˜: {len(fine_result.sub_problems)} ä¸ª, "
                       f"éœ€è¦æ¾„æ¸…: {fine_result.needs_clarification}")
            
            # ========== ç”Ÿæˆè·¯ç”±è®¡åˆ’ ==========
            routing_plan = self._build_routing_plan(
                query=query,
                coarse_result=coarse_result,
                fine_result=fine_result,
                filtered_context=filtered_context,
                trace_id=trace_id
            )
            
            return routing_plan
            
        except Exception as e:
            logger.error(f"æ„å›¾è¯†åˆ«å¤±è´¥: {str(e)}", exc_info=True)
            # é™çº§åˆ°ç®€å•è·¯ç”±
            return self._build_fallback_routing_plan(query, trace_id)
    
    def _build_simple_routing_plan(
        self,
        query: str,
        coarse_result: CoarseIntentResult,
        trace_id: Optional[str]
    ) -> RoutingPlan:
        """æ„å»ºç®€å•è·¯ç”±è®¡åˆ’ï¼ˆæ— éœ€Stage 2ï¼‰"""
        route_mapping = {
            CoarseIntent.CHITCHAT: RouteType.FAST_PATH,
            CoarseIntent.CONFIRMATION: RouteType.FAST_PATH,
            CoarseIntent.META_QUERY: RouteType.SINGLE_RETRIEVAL,
            CoarseIntent.SINGLE_FACT: RouteType.SINGLE_RETRIEVAL,
            CoarseIntent.PROCEDURE: RouteType.SINGLE_RETRIEVAL,
            CoarseIntent.DEFINITION: RouteType.SINGLE_RETRIEVAL,
            CoarseIntent.MULTI_FACT: RouteType.MULTI_HOP,
            CoarseIntent.COMPARISON: RouteType.MULTI_HOP,
            CoarseIntent.TROUBLESHOOTING: RouteType.MULTI_HOP,
            CoarseIntent.ANALYSIS: RouteType.MULTI_HOP,
            CoarseIntent.AMBIGUOUS: RouteType.CLARIFICATION,
            CoarseIntent.OUT_OF_DOMAIN: RouteType.FALLBACK
        }
        
        return RoutingPlan(
            original_query=query,
            coarse_result=coarse_result,
            fine_result=FineIntentResult(
                analysis="åŸºäºé«˜ç½®ä¿¡åº¦ç²—æ„å›¾çš„ç›´æ¥è·¯ç”±",
                sub_problems=[],
                overall_confidence=coarse_result.confidence,
                execution_strategy="simple",
                suggestions=[]
            ),
            final_route=route_mapping.get(coarse_result.coarse_intent, RouteType.FALLBACK),
            context_blocks=[],
            confidence=coarse_result.confidence,
            trace_id=trace_id or ""
        )
    
    def _build_routing_plan(
        self,
        query: str,
        coarse_result: CoarseIntentResult,
        fine_result: FineIntentResult,
        filtered_context: List[ConversationTurn],
        trace_id: Optional[str]
    ) -> RoutingPlan:
        """æ„å»ºå®Œæ•´è·¯ç”±è®¡åˆ’"""
        
        # ç¡®å®šæœ€ç»ˆè·¯ç”±ç±»å‹
        if fine_result.needs_clarification:
            final_route = RouteType.CLARIFICATION
        elif all(sp.route_type == RouteType.FAST_PATH for sp in fine_result.sub_problems):
            final_route = RouteType.FAST_PATH
        elif any(sp.route_type == RouteType.MULTI_HOP for sp in fine_result.sub_problems):
            final_route = RouteType.MULTI_HOP
        else:
            final_route = RouteType.SINGLE_RETRIEVAL
        
        # æ„å»ºcontext blocks
        context_blocks = self._build_context_blocks(
            query, coarse_result, fine_result, filtered_context
        )
        
        return RoutingPlan(
            original_query=query,
            coarse_result=coarse_result,
            fine_result=fine_result,
            final_route=final_route,
            context_blocks=context_blocks,
            confidence=fine_result.overall_confidence,
            trace_id=trace_id or ""
        )
    
    def _build_context_blocks(
        self,
        query: str,
        coarse_result: CoarseIntentResult,
        fine_result: FineIntentResult,
        filtered_context: List[ConversationTurn]
    ) -> List[Dict]:
        """æ„å»ºä¸Šä¸‹æ–‡å—ä¾›ä¸‹æ¸¸ä½¿ç”¨"""
        blocks = []
        
        # 1. æŸ¥è¯¢ä¿¡æ¯å—
        blocks.append({
            "type": "query_info",
            "data": {
                "original_query": query,
                "coarse_intent": coarse_result.coarse_intent.value,
                "fine_intents": [sp.intent_type.value for sp in fine_result.sub_problems],
                "confidence": fine_result.overall_confidence
            }
        })
        
        # 2. ç›¸å…³å†å²å—
        if filtered_context:
            blocks.append({
                "type": "relevant_history",
                "data": {
                    "turns": [
                        {
                            "role": turn.role,
                            "summary": turn.summary,
                            "entities": [{"name": e.name, "type": e.type} for e in turn.entities]
                        }
                        for turn in filtered_context
                    ]
                }
            })
        
        # 3. å­é—®é¢˜å—
        if fine_result.sub_problems:
            blocks.append({
                "type": "sub_problems",
                "data": {
                    "problems": [
                        {
                            "id": sp.id,
                            "question": sp.refined_question,
                            "intent": sp.intent_type.value,
                            "route": sp.route_type.value,
                            "agent": sp.target_agent,
                            "complexity": sp.estimated_complexity,
                            "dependencies": sp.dependencies
                        }
                        for sp in fine_result.sub_problems
                    ],
                    "execution_strategy": fine_result.execution_strategy
                }
            })
        
        # 4. å»ºè®®æ–‡æ¡£èŒƒå›´
        if coarse_result.suggested_doc_scope:
            blocks.append({
                "type": "doc_scope",
                "data": {
                    "suggested_docs": coarse_result.suggested_doc_scope
                }
            })
        
        return blocks
    
    def _build_fallback_routing_plan(
        self,
        query: str,
        trace_id: Optional[str]
    ) -> RoutingPlan:
        """æ„å»ºé™çº§è·¯ç”±è®¡åˆ’"""
        return RoutingPlan(
            original_query=query,
            coarse_result=CoarseIntentResult(
                coarse_intent=CoarseIntent.AMBIGUOUS,
                confidence=0.5,
                relevant_context_indices=[],
                selection_reasoning="æ„å›¾è¯†åˆ«å¤±è´¥ï¼Œä½¿ç”¨é™çº§ç­–ç•¥",
                suggested_doc_scope=[],
                needs_refinement=True
            ),
            fine_result=FineIntentResult(
                analysis="æ„å›¾è¯†åˆ«å¤±è´¥ï¼Œä½¿ç”¨é™çº§ç­–ç•¥",
                sub_problems=[],
                overall_confidence=0.5,
                execution_strategy="simple",
                suggestions=["ä½¿ç”¨é»˜è®¤è·¯ç”±"]
            ),
            final_route=RouteType.FALLBACK,
            context_blocks=[],
            confidence=0.5,
            trace_id=trace_id or ""
        )
```

### 6.5 æ¶ˆæ­§å¤„ç†å™¨

```python
# backend/app/agents/clarification_handler.py

from typing import Dict, Any, Optional
from .intent_models import FineIntentResult, SubProblem

class ClarificationHandler:
    """æ¾„æ¸…è¯·æ±‚å¤„ç†å™¨"""
    
    def create_clarification_response(
        self,
        fine_result: FineIntentResult
    ) -> Dict[str, Any]:
        """åˆ›å»ºæ¾„æ¸…å“åº”è¿”å›ç»™ç”¨æˆ·"""
        if not fine_result.needs_clarification:
            return {"needs_clarification": False}
        
        clarification_points = []
        for sp in fine_result.sub_problems:
            if sp.needs_clarification:
                clarification_points.append({
                    "sub_problem_id": sp.id,
                    "question": sp.clarification_question,
                    "options": sp.clarification_options or [],
                    "type": sp.ambiguity_type
                })
        
        return {
            "needs_clarification": True,
            "clarification_session": fine_result.clarification_session,
            "clarification_points": clarification_points,
            "message": self._generate_clarification_message(clarification_points)
        }
    
    def _generate_clarification_message(
        self,
        points: List[Dict[str, Any]]
    ) -> str:
        """ç”Ÿæˆå‹å¥½çš„æ¾„æ¸…æ¶ˆæ¯"""
        if len(points) == 1:
            point = points[0]
            msg = f"ä¸ºäº†æ›´å¥½åœ°å›ç­”æ‚¨çš„é—®é¢˜ï¼Œ{point['question']}"
            if point["options"]:
                options_text = "\n".join(
                    f"{i+1}. {opt['text']}" 
                    for i, opt in enumerate(point["options"])
                )
                msg += f"\n\n{options_text}"
            return msg
        else:
            msg = "ä¸ºäº†æ›´å¥½åœ°å›ç­”æ‚¨çš„é—®é¢˜ï¼Œæˆ‘éœ€è¦æ¾„æ¸…ä»¥ä¸‹å‡ ç‚¹ï¼š\n"
            for i, point in enumerate(points, 1):
                msg += f"\n{i}. {point['question']}"
            return msg
    
    def process_clarification_response(
        self,
        clarification_session: Dict[str, Any],
        user_response: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        å¤„ç†ç”¨æˆ·çš„æ¾„æ¸…å›ç­”
        è¿”å›æ›´æ–°åçš„æŸ¥è¯¢æˆ–éœ€è¦ç»§ç»­æ¾„æ¸…
        """
        # è§£æç”¨æˆ·å›ç­”
        resolved_ambiguities = {}
        for point_id, answer in user_response.get("answers", {}).items():
            resolved_ambiguities[point_id] = answer
        
        # æ„å»ºæ¾„æ¸…åçš„æŸ¥è¯¢
        refined_query = self._build_refined_query(
            clarification_session["original_query"],
            resolved_ambiguities
        )
        
        return {
            "status": "resolved",
            "refined_query": refined_query,
            "resolved_ambiguities": resolved_ambiguities,
            "needs_re_analysis": True  # éœ€è¦é‡æ–°è¿›è¡Œæ„å›¾è¯†åˆ«
        }
    
    def _build_refined_query(
        self,
        original_query: str,
        resolved_ambiguities: Dict[str, Any]
    ) -> str:
        """æ ¹æ®æ¾„æ¸…ç»“æœæ„å»ºä¼˜åŒ–åçš„æŸ¥è¯¢"""
        # ç®€å•å®ç°ï¼šå°†æ¾„æ¸…ä¿¡æ¯é™„åŠ åˆ°åŸæŸ¥è¯¢
        # å®é™…åº”ç”¨ä¸­å¯ä»¥æ ¹æ®æ­§ä¹‰ç±»å‹è¿›è¡Œæ›´æ™ºèƒ½çš„æ•´åˆ
        refinements = []
        for point_id, answer in resolved_ambiguities.items():
            if isinstance(answer, dict) and "text" in answer:
                refinements.append(answer["text"])
            else:
                refinements.append(str(answer))
        
        if refinements:
            return f"{original_query} (è¡¥å……ä¿¡æ¯: {'; '.join(refinements)})"
        return original_query
```

---

## ä¸ƒã€ä¸ç°æœ‰ç³»ç»Ÿé›†æˆ

### 7.1 æ›¿æ¢PromptAgentV2

```python
# backend/app/agents/prompt_agent_v2_enhanced.py

from .intent_orchestrator import IntentOrchestrator
from .clarification_handler import ClarificationHandler
from ..models.schemas import QAResponse

class PromptAgentV2Enhanced:
    """å¢å¼ºç‰ˆPromptAgentV2 - é›†æˆä¸¤é˜¶æ®µæ„å›¾è¯†åˆ«"""
    
    def __init__(self):
        self.orchestrator = IntentOrchestrator()
        self.clarification_handler = ClarificationHandler()
        
    async def process(
        self,
        query: str,
        session_id: str,
        doc_id: Optional[str] = None,
        trace_ctx: Optional[Dict] = None
    ) -> Dict[str, Any]:
        """
        å¤„ç†ç”¨æˆ·æŸ¥è¯¢
        
        è¿”å›:
        - æ­£å¸¸æƒ…å†µ: è·¯ç”±å†³ç­–ç»“æœ
        - éœ€è¦æ¾„æ¸…: æ¾„æ¸…è¯·æ±‚
        """
        trace_id = trace_ctx.get("trace_id") if trace_ctx else None
        
        # 1. è·å–ä¼šè¯å†å²
        session_history = await self._get_session_history(session_id)
        
        # 2. æ‰§è¡Œä¸¤é˜¶æ®µæ„å›¾è¯†åˆ«
        routing_plan = await self.orchestrator.process(
            query=query,
            session_history=session_history,
            available_docs=self._get_available_docs(),
            available_tools=self._get_available_tools(),
            trace_ctx=trace_ctx
        )
        
        # 3. æ£€æŸ¥æ˜¯å¦éœ€è¦æ¾„æ¸…
        if routing_plan.fine_result.needs_clarification:
            clarification_response = self.clarification_handler.create_clarification_response(
                routing_plan.fine_result
            )
            # ä¿å­˜æ¾„æ¸…ä¼šè¯çŠ¶æ€
            await self._save_clarification_session(
                session_id, 
                routing_plan.fine_result.clarification_session
            )
            return {
                "type": "clarification_needed",
                "data": clarification_response
            }
        
        # 4. è¿”å›è·¯ç”±å†³ç­–
        return {
            "type": "routing_decision",
            "data": {
                "route": routing_plan.final_route.value,
                "confidence": routing_plan.confidence,
                "context_blocks": routing_plan.context_blocks,
                "sub_problems": [
                    {
                        "id": sp.id,
                        "question": sp.refined_question,
                        "intent": sp.intent_type.value,
                        "route": sp.route_type.value,
                        "agent": sp.target_agent
                    }
                    for sp in routing_plan.fine_result.sub_problems
                ],
                "trace_id": trace_id
            }
        }
    
    async def process_clarification(
        self,
        session_id: str,
        user_response: Dict[str, Any],
        trace_ctx: Optional[Dict] = None
    ) -> Dict[str, Any]:
        """å¤„ç†ç”¨æˆ·çš„æ¾„æ¸…å›ç­”"""
        # 1. è·å–æ¾„æ¸…ä¼šè¯
        clarification_session = await self._get_clarification_session(session_id)
        
        # 2. å¤„ç†æ¾„æ¸…å›ç­”
        result = self.clarification_handler.process_clarification_response(
            clarification_session,
            user_response
        )
        
        # 3. å¦‚æœéœ€è¦é‡æ–°åˆ†æ
        if result.get("needs_re_analysis"):
            # ä½¿ç”¨æ¾„æ¸…åçš„æŸ¥è¯¢é‡æ–°è¿›è¡Œæ„å›¾è¯†åˆ«
            refined_query = result["refined_query"]
            return await self.process(
                query=refined_query,
                session_id=session_id,
                trace_ctx=trace_ctx
            )
        
        return result
```

### 7.2 APIè·¯ç”±æ›´æ–°

```python
# backend/app/api/routes/qa.py

from fastapi import APIRouter, Depends
from app.agents.prompt_agent_v2_enhanced import PromptAgentV2Enhanced

router = APIRouter()
prompt_agent = PromptAgentV2Enhanced()

@router.post("/agent/qa")
async def qa_chat(request: QARequest):
    """ä¸»QAå…¥å£"""
    # æ£€æŸ¥æ˜¯å¦æœ‰å¾…å¤„ç†çš„æ¾„æ¸…ä¼šè¯
    pending_clarification = await check_pending_clarification(request.session_id)
    
    if pending_clarification:
        # å¤„ç†æ¾„æ¸…å›ç­”
        result = await prompt_agent.process_clarification(
            session_id=request.session_id,
            user_response=request.message,
            trace_ctx=request.trace_ctx
        )
    else:
        # æ­£å¸¸æ„å›¾è¯†åˆ«æµç¨‹
        result = await prompt_agent.process(
            query=request.message,
            session_id=request.session_id,
            doc_id=request.doc_id,
            trace_ctx=request.trace_ctx
        )
    
    # æ ¹æ®ç»“æœç±»å‹å¤„ç†
    if result["type"] == "clarification_needed":
        return QAResponse(
            type="clarification",
            message=result["data"]["message"],
            clarification_points=result["data"]["clarification_points"]
        )
    else:
        # è¿›å…¥DAGæ‰§è¡Œ
        routing_decision = result["data"]
        return await execute_dag(routing_decision)
```

---

## å…«ã€æ€§èƒ½ä¼˜åŒ–å»ºè®®

### 8.1 ç¼“å­˜ç­–ç•¥

```python
# ç¼“å­˜Stage 1ç»“æœï¼ˆç›¸åŒæŸ¥è¯¢+ç›¸ä¼¼ä¸Šä¸‹æ–‡ï¼‰
@cache(ttl=300, key_builder=lambda query, history: hash_query_context(query, history))
async def stage1_analyze(query, history, docs):
    ...

# ç¼“å­˜å¸¸è§æ„å›¾çš„Stage 2ç»“æœ
@cache(ttl=600)
async def stage2_analyze(query, coarse_intent, context, tools):
    ...
```

### 8.2 å¹¶è¡ŒåŒ–

```python
# Stage 1å’Œä¸Šä¸‹æ–‡é¢„å¤„ç†å¹¶è¡Œ
async def optimized_process(query, history):
    # é¢„å¤„ç†å†å²ï¼ˆå®ä½“æå–ã€æ€»ç»“ï¼‰ä¸Stage 1å¹¶è¡Œ
    preprocessed_future = preprocess_history(history)
    stage1_future = stage1_analyze(query, history, docs)
    
    coarse_result, preprocessed = await asyncio.gather(
        stage1_future, preprocessed_future
    )
    
    # Stage 2ä½¿ç”¨é¢„å¤„ç†ç»“æœ
    fine_result = await stage2_analyze(
        query, coarse_result, preprocessed, tools
    )
```

### 8.3 é™çº§ç­–ç•¥

```python
async def process_with_fallback(query, history):
    try:
        # å°è¯•å®Œæ•´ä¸¤é˜¶æ®µè¯†åˆ«
        return await orchestrator.process(query, history)
    except LLMTimeoutError:
        # LLMè¶…æ—¶ï¼Œä½¿ç”¨è§„åˆ™è·¯ç”±
        logger.warning("LLMè¶…æ—¶ï¼Œä½¿ç”¨è§„åˆ™è·¯ç”±")
        return rule_based_router.route(query)
    except LLMError:
        # LLMé”™è¯¯ï¼Œä½¿ç”¨ç®€åŒ–ç‰ˆè¯†åˆ«
        logger.warning("LLMé”™è¯¯ï¼Œä½¿ç”¨ç®€åŒ–è¯†åˆ«")
        return await simplified_orchestrator.process(query, history)
```

---

## æ€»ç»“

æœ¬æ–¹æ¡ˆé€šè¿‡**ä¸¤é˜¶æ®µæ„å›¾è¯†åˆ«**å¤§å¹…æå‡ç³»ç»Ÿæ™ºèƒ½æ€§ï¼š

### æ ¸å¿ƒæ”¹è¿›

1. **ä¸Šä¸‹æ–‡æ™ºèƒ½ç­›é€‰**ï¼šåªä¿ç•™ç›¸å…³å†å²ï¼Œå‡å°‘å™ªå£°å¹²æ‰°
2. **ç»†ç²’åº¦é—®é¢˜æ‹†è§£**ï¼šå¤æ‚é—®é¢˜åˆ†è§£ä¸ºå¯ç®¡ç†çš„å­é—®é¢˜
3. **ä¸»åŠ¨æ¶ˆæ­§**ï¼šåœ¨é—®é¢˜æ‹†è§£é˜¶æ®µè¯†åˆ«å¹¶å¤„ç†æ­§ä¹‰ç‚¹
4. **ç²¾å‡†è·¯ç”±**ï¼šåŸºäºè¯­ä¹‰ç†è§£è€Œéå…³é”®è¯åŒ¹é…
5. **å¯è§£é‡Šæ€§**ï¼šæ¯ä¸ªå†³ç­–éƒ½æœ‰æ˜ç¡®çš„ç†ç”±

### é¢„æœŸæ”¶ç›Š

| æŒ‡æ ‡ | é¢„æœŸæå‡ |
|------|---------|
| è·¯ç”±å‡†ç¡®ç‡ | +25-35% |
| å¤šè½®å¯¹è¯ç†è§£ | +40% |
| å¤æ‚é—®é¢˜å¤„ç† | +50% |
| ç”¨æˆ·æ»¡æ„åº¦ | +30% |
| è¯¯è·¯ç”±ç‡ | -40% |

### å®æ–½å»ºè®®

1. **æ¸è¿›å¼ä¸Šçº¿**ï¼šå…ˆåœ¨é«˜ä»·å€¼åœºæ™¯è¯•ç‚¹
2. **A/Bæµ‹è¯•**ï¼šå¯¹æ¯”æ–°æ—§æ–¹æ¡ˆçš„æ•ˆæœ
3. **æŒç»­ä¼˜åŒ–**ï¼šæ ¹æ®åé¦ˆè¿­ä»£Prompt
4. **ç›‘æ§å…œåº•**ï¼šä¿ç•™è§„åˆ™è·¯ç”±ä½œä¸ºåå¤‡

---

**å®Œæ•´ä»£ç å®ç°**ï¼šè§ä¸Šè¿°å„æ¨¡å—ä»£ç 
**Promptæ¨¡æ¿**ï¼šéœ€æ ¹æ®å®é™…ä¸šåŠ¡å¾®è°ƒ
**é›†æˆæ–¹å¼**ï¼šæ›¿æ¢ç°æœ‰PromptAgentV2ï¼Œä¿æŒæ¥å£å…¼å®¹
